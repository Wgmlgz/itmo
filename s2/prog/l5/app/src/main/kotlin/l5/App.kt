/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package l5

import java.time.*
import java.time.format.DateTimeFormatter
import java.util.*
import kotlin.text.*

public class Product(
    name: String,
    coordinates: Coordinates,
    price: Double,
    manufactureCost: Float,
    unitOfMeasure: UnitOfMeasure,
    owner: Person
) {
  companion object {
    var last_id: Long = 1
    fun getId() = last_id++

    fun parseStdin(): Product {
      val scanner = Scanner(System.`in`)

      val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")

      fun <T> readVal(prompt: String, parser: (s: String) -> T): T {
        var res: T? = null
        print("$prompt: ")
        while (res == null) {
          try {

            val line = readLine()
            if (line != null) {

              res = parser(line)
            }
          } catch (e: Exception) {
            println("invalid value: $e")
          }
        }
        return res
      }

      fun <T> readNested(prompt: String, parser: () -> T): T {
        println("$prompt: ")
        return parser()
      }

      return Product(
          readVal("name", { s -> s }),
          readNested(
              "coordinates",
              {
                Coordinates(
                    readVal("coordinates.x", { s -> s.toFloat() }),
                    readVal("coordinates.y", { s -> s.toLong() })
                )
              }
          ),
          readVal("price", { s -> s.toDouble() }),
          readVal("manufactureCost", { s -> s.toFloat() }),
          readVal("unitOfMeasure", { s -> UnitOfMeasure.valueOf(s) }),
          readNested(
              "owner",
              {
                Person(
                    readVal("owner.name", { s -> s }),
                    readVal("owner.birthday", { s -> LocalDateTime.parse(s, formatter) }),
                    readVal("owner.nationality", { s -> Country.valueOf(s) }),
                )
              }
          ),
      )
    }
  }
  val id = getId()
  val creationDate = ZonedDateTime.now()
}

// fun input(): Product {
//   val res = Product(

//   )
//   return res
// }
//     private Long id; //Поле не может быть null, Значение поля должно быть больше 0, Значение
// этого поля должно быть уникальным, Значение этого поля должно генерироваться автоматически
//     private String name; //Поле не может быть null, Строка не может быть пустой
//     private Coordinates coordinates; //Поле не может быть null
//     private java.time.ZonedDateTime creationDate; //Поле не может быть null, Значение этого поля
// должно генерироваться автоматически
//     private double price; //Значение поля должно быть больше 0
//     private float manufactureCost;
//     private UnitOfMeasure unitOfMeasure; //Поле может быть null
//     private Person owner; //Поле не может быть null
public class Coordinates(x: Float, y: Long) {
  // companion object {
  //   fun parse(input: String): Coordinates?
  // }
}

public class Person(name: String, birthday: LocalDateTime?, nationality: Country) {}

public enum class UnitOfMeasure {
  SQUARE_METERS,
  LITERS,
  GRAMS
}

// inline fun <reified T : Enum<T>> parseEnum(type: String): T? {
//   return try {
//     java.lang.Enum.valueOf(T::class.java, type)
//   } catch (e: IllegalArgumentException) {
//     null
//   }
// }

public enum class Country {
  CHINA,
  SOUTH_KOREA,
  JAPAN
}

// class RegexWhenArgument(val whenArgument: CharSequence) {
//   operator fun equals(other: String) = other is String && Regex(other).matches(whenArgument)

//   override operator fun equals(whenEntry: Any?) = (whenArgument == whenEntry)
// }

class Sus {
  val id = "(\\d+)"
  val item = "(.+)"

  fun help() {
    println(commands.joinToString("\n") { (a, b, c) -> b })
  }
  val commands: Array<Triple<String, String, (m: MatchResult) -> Unit>> =
      arrayOf(
          Triple("help", "help : вывести справку по доступным командам", { m -> help() }),
          Triple(
              "info",
              "info : вывести в стандартный поток вывода информацию о коллекции (тип, дата инициализации, количество элементов и т.д.)",
              { m -> true }
          ),
          Triple(
              "show",
              "show : вывести в стандартный поток вывода все элементы коллекции в строковом представлении",
              { m -> true }
          ),
          Triple("add", "add {element} : добавить новый элемент в коллекцию", { m -> true }),
          Triple(
              "update $id $item",
              "update id {element} : обновить значение элемента коллекции, id которого равен заданному",
              { m -> true }
          ),
          Triple(
              "remove_by_id $id",
              "remove_by_id id : удалить элемент из коллекции по его id",
              { m -> true }
          ),
          Triple("clear", "clear : очистить коллекцию", { m -> true }),
          Triple("save", "save : сохранить коллекцию в файл", { m -> true }),
          Triple(
              "execute_script $item",
              "execute_script file_name : считать и исполнить скрипт из указанного файла. В скрипте содержатся команды в таком же виде, в котором их вводит пользователь в интерактивном режиме.",
              { m -> true }
          ),
          Triple("exit", "exit : завершить программу (без сохранения в файл)", { m -> true }),
          Triple(
              "remove_first",
              "remove_first : удалить первый элемент из коллекции",
              { m -> true }
          ),
          Triple(
              "and_if_max $item",
              "add_if_max {element} : добавить новый элемент в коллекцию, если его значение превышает значение наибольшего элемента этой коллекции",
              { m -> true }
          ),
          Triple(
              "remove_greater $item",
              "remove_greater {element} : удалить из коллекции все элементы, превышающие заданный",
              { m -> true }
          ),
          Triple(
              "min_by_manufacture_cost",
              "min_by_manufacture_cost : вывести любой объект из коллекции, значение поля manufactureCost которого является минимальным",
              { m -> true }
          ),
          Triple(
              "count_less_than_owner $item",
              "count_less_than_owner owner : вывести количество элементов, значение поля owner которых меньше заданного",
              { m -> true }
          ),
          Triple(
              "filter_contains_name $item",
              "filter_contains_name name : вывести элементы, значение поля name которых содержит заданную подстроку",
              { m -> true }
          ),
      )

  fun sus(r: String, input: String, cb: (m: MatchResult) -> Unit): Boolean {
    var c = Regex(r).find(input)
    if (c == null) return false
    cb(c)
    return true
  }
  fun cmd(input: String) {

    run lit@{ commands.forEach { (r, help, cb) -> if (sus(r, input, cb)) return@lit } }
  }
}

fun main() {
  println("sus impostor228")
  val g = Sus()
  g.cmd("help")
  g.cmd("update id 666")
  g.cmd("update id")
  g.cmd("update id 777")

  Product.parseStdin()
}
